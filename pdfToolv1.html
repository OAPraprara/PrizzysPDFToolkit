<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Toolkit</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.min.js"></script>
    <script src="https://unpkg.com/downloadjs@1.4.7"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.min.js';
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        .dropzone {
            border: 2px dashed #9CA3AF;
            border-radius: 0.5rem;
            transition: all 0.3s ease;
        }

        .dropzone.active {
            border-color: #3B82F6;
            background-color: #EFF6FF;
        }

        .page-thumbnail {
            transition: all 0.2s ease;
            position: relative;
        }

        .page-thumbnail:hover {
            transform: scale(1.03);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }

        .page-thumbnail.selected {
            border-color: #3B82F6;
            background-color: #EFF6FF;
            box-shadow: 0 0 0 2px #3B82F6;
        }

        .page-badge {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: #3B82F6;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .page-thumbnail.selected .page-badge {
            opacity: 1;
        }

        /* Custom scrollbar */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #a1a1a1;
        }
    </style>
</head>

<body class="bg-gray-50 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <header class="text-center mb-10">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-800 mb-2">PDF Toolkit</h1>
            <p class="text-gray-600 max-w-2xl mx-auto">Edit, delete pages, merge, and extract from PDFs with this simple
                web tool</p>
        </header>

        <div class="flex flex-col lg:flex-row gap-8">
            <!-- Left sidebar for navigation -->
            <div class="w-full lg:w-1/4 bg-white rounded-lg shadow-md p-4 h-fit">
                <div class="space-y-2">
                    <button id="editTabBtn"
                        class="w-full py-3 px-4 rounded-lg bg-blue-600 text-white font-medium flex items-center justify-center space-x-2">
                        <i class="fas fa-edit"></i>
                        <span>Edit PDF</span>
                    </button>
                    <button id="extractTabBtn"
                        class="w-full py-3 px-4 rounded-lg bg-gray-200 text-gray-700 font-medium flex items-center justify-center space-x-2 hover:bg-gray-300">
                        <i class="fas fa-cut"></i>
                        <span>Extract Pages</span>
                    </button>
                    <button id="mergeTabBtn"
                        class="w-full py-3 px-4 rounded-lg bg-gray-200 text-gray-700 font-medium flex items-center justify-center space-x-2 hover:bg-gray-300">
                        <i class="fas fa-object-group"></i>
                        <span>Merge PDFs</span>
                    </button>
                </div>

                <div class="mt-8">
                    <h3 class="text-lg font-semibold text-gray-700 mb-3">How to use</h3>
                    <ul class="space-y-3 text-gray-600 text-sm">
                        <li class="flex items-start space-x-2">
                            <i class="fas fa-check-circle text-blue-500 mt-1"></i>
                            <span>Select pages to delete (Edit Tab)</span>
                        </li>
                        <li class="flex items-start space-x-2">
                            <i class="fas fa-check-circle text-blue-500 mt-1"></i>
                            <span>Select pages to keep (Extract Tab)</span>
                        </li>
                        <li class="flex items-start space-x-2">
                            <i class="fas fa-check-circle text-blue-500 mt-1"></i>
                            <span>Preview extracted result before download</span>
                        </li>
                        <li class="flex items-start space-x-2">
                            <i class="fas fa-check-circle text-blue-500 mt-1"></i>
                            <span>Merge multiple files into one</span>
                        </li>
                    </ul>
                </div>
            </div>

            <!-- Main content area -->
            <div class="w-full lg:w-3/4">
                <!-- Edit PDF Section -->
                <div id="editSection" class="bg-white rounded-lg shadow-md p-6 mb-8">
                    <h2 class="text-xl font-semibold text-gray-800 mb-4">Edit PDF - Remove Pages</h2>

                    <div id="editDropzone" class="dropzone p-8 text-center mb-6 cursor-pointer">
                        <div class="flex flex-col items-center justify-center space-y-2">
                            <i class="fas fa-file-pdf text-4xl text-red-500"></i>
                            <p class="text-gray-700 font-medium">Drag & drop your PDF here</p>
                            <p class="text-gray-500 text-sm">or click to browse files</p>
                            <input type="file" id="pdfInput" accept=".pdf" class="hidden">
                        </div>
                    </div>

                    <div id="pdfInfo" class="hidden mb-6">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-lg font-medium text-gray-700">Select pages to <span
                                    class="text-red-600">remove</span></h3>
                            <div class="flex space-x-2">
                                <button id="selectAllBtn"
                                    class="px-3 py-1 bg-gray-200 text-gray-700 rounded text-sm hover:bg-gray-300">Select
                                    All</button>
                                <button id="deselectAllBtn"
                                    class="px-3 py-1 bg-gray-200 text-gray-700 rounded text-sm hover:bg-gray-300">Deselect
                                    All</button>
                            </div>
                        </div>

                        <div id="pageThumbnails"
                            class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 mb-6 max-h-96 overflow-y-auto custom-scrollbar p-2">
                            <!-- Page thumbnails will be inserted here -->
                        </div>

                        <div class="flex justify-end">
                            <button id="processEditBtn"
                                class="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
                                disabled>
                                <i class="fas fa-download mr-2"></i>Download Edited PDF
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Extract PDF Section (initially hidden) -->
                <div id="extractSection" class="bg-white rounded-lg shadow-md p-6 hidden">
                    <h2 class="text-xl font-semibold text-gray-800 mb-4">Extract Pages</h2>

                    <div id="extractDropzone" class="dropzone p-8 text-center mb-6 cursor-pointer">
                        <div class="flex flex-col items-center justify-center space-y-2">
                            <i class="fas fa-file-pdf text-4xl text-red-500"></i>
                            <p class="text-gray-700 font-medium">Drag & drop your PDF here</p>
                            <p class="text-gray-500 text-sm">or click to browse files</p>
                            <input type="file" id="extractPdfInput" accept=".pdf" class="hidden">
                        </div>
                    </div>

                    <div id="extractWorkArea" class="hidden">
                        <!-- Step 1: Selection -->
                        <div class="border-b border-gray-200 pb-6 mb-6">
                            <div
                                class="flex flex-col md:flex-row justify-between items-start md:items-center mb-4 gap-4">
                                <div>
                                    <h3 class="text-lg font-medium text-gray-700">1. Select pages to <span
                                            class="text-green-600">keep</span></h3>
                                    <p id="largeFileMsg" class="text-xs text-orange-600 hidden mt-1"><i
                                            class="fas fa-exclamation-triangle mr-1"></i>Large file detected. Thumbnails
                                        hidden for performance.</p>
                                </div>
                                <div class="w-full md:w-auto">
                                    <label class="block text-gray-500 text-xs font-bold mb-1" for="pageRange">
                                        Type range (e.g. 1-10, 15)
                                    </label>
                                    <input
                                        class="shadow appearance-none border rounded w-full md:w-64 py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline"
                                        id="pageRange" type="text" placeholder="e.g. 1-3, 5">
                                </div>
                            </div>

                            <div id="extractThumbnailContainer" class="relative">
                                <div id="extractSourceThumbnails"
                                    class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 mb-4 max-h-80 overflow-y-auto custom-scrollbar p-2 bg-gray-50 rounded-lg border border-gray-100">
                                    <!-- Source thumbnails go here -->
                                </div>
                                <div id="loadThumbnailsOverlay"
                                    class="hidden absolute inset-0 bg-white bg-opacity-90 z-10 flex flex-col items-center justify-center rounded-lg border border-gray-200">
                                    <p class="text-gray-700 font-medium mb-3">Thumbnails not loaded for large file</p>
                                    <button id="btnLoadThumbnails"
                                        class="px-4 py-2 bg-gray-200 hover:bg-gray-300 text-gray-800 rounded text-sm font-medium">
                                        Load Thumbnails Anyway (May cause lag)
                                    </button>
                                </div>
                            </div>

                            <div class="flex justify-end mt-4">
                                <button id="btnPreviewExtract"
                                    class="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed">
                                    <i class="fas fa-eye mr-2"></i>Preview Result
                                </button>
                            </div>
                        </div>

                        <!-- Step 2: Preview & Download -->
                        <div id="extractPreviewArea"
                            class="hidden bg-indigo-50 rounded-lg p-6 border border-indigo-100">
                            <h3 class="text-lg font-medium text-gray-800 mb-4 flex items-center">
                                <i class="fas fa-check-circle text-green-500 mr-2"></i>
                                2. Preview Extracted Result
                            </h3>

                            <div id="extractResultThumbnails"
                                class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 mb-6 max-h-80 overflow-y-auto custom-scrollbar p-2">
                                <!-- Result thumbnails go here -->
                            </div>

                            <div class="flex flex-col md:flex-row items-end gap-4 border-t border-indigo-200 pt-4">
                                <div class="w-full md:w-1/2">
                                    <label class="block text-gray-700 text-sm font-bold mb-2" for="outputFilename">
                                        Output Filename
                                    </label>
                                    <div class="flex items-center">
                                        <input
                                            class="shadow appearance-none border rounded-l w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline"
                                            id="outputFilename" type="text" value="extracted_pages">
                                        <span
                                            class="bg-gray-200 border border-l-0 border-gray-300 rounded-r px-3 py-2 text-gray-600 text-sm font-medium">.pdf</span>
                                    </div>
                                </div>
                                <div class="w-full md:w-auto">
                                    <button id="btnDownloadExtract"
                                        class="w-full px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 font-bold shadow-md">
                                        <i class="fas fa-download mr-2"></i>Download Extracted PDF
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Merge PDFs Section (initially hidden) -->
                <div id="mergeSection" class="bg-white rounded-lg shadow-md p-6 hidden">
                    <h2 class="text-xl font-semibold text-gray-800 mb-4">Merge Multiple PDFs</h2>

                    <div id="mergeDropzone" class="dropzone p-8 text-center mb-6 cursor-pointer">
                        <div class="flex flex-col items-center justify-center space-y-2">
                            <i class="fas fa-file-pdf text-4xl text-red-500"></i>
                            <p class="text-gray-700 font-medium">Drag & drop PDFs to merge</p>
                            <p class="text-gray-500 text-sm">or click to browse files (multiple selection allowed)</p>
                            <input type="file" id="mergePdfInput" accept=".pdf" multiple class="hidden">
                        </div>
                    </div>

                    <div id="mergeFilesList" class="hidden mb-6">
                        <h3 class="text-lg font-medium text-gray-700 mb-3">Files to merge (drag to reorder)</h3>

                        <ul id="mergeList" class="space-y-2 mb-4 max-h-64 overflow-y-auto custom-scrollbar p-2">
                            <!-- Files to merge will be listed here -->
                        </ul>

                        <div class="flex justify-between">
                            <button id="clearMergeBtn"
                                class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">
                                <i class="fas fa-trash-alt mr-2"></i>Clear All
                            </button>
                            <button id="processMergeBtn"
                                class="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
                                disabled>
                                <i class="fas fa-download mr-2"></i>Download Merged PDF
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // Tab switching logic
            const tabs = {
                edit: { btn: document.getElementById('editTabBtn'), section: document.getElementById('editSection') },
                extract: { btn: document.getElementById('extractTabBtn'), section: document.getElementById('extractSection') },
                merge: { btn: document.getElementById('mergeTabBtn'), section: document.getElementById('mergeSection') }
            };

            function switchTab(activeTabName) {
                Object.keys(tabs).forEach(key => {
                    const tab = tabs[key];
                    if (key === activeTabName) {
                        tab.section.classList.remove('hidden');
                        tab.btn.classList.remove('bg-gray-200', 'text-gray-700', 'hover:bg-gray-300');
                        tab.btn.classList.add('bg-blue-600', 'text-white');
                    } else {
                        tab.section.classList.add('hidden');
                        tab.btn.classList.remove('bg-blue-600', 'text-white');
                        tab.btn.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-gray-300');
                    }
                });
            }

            tabs.edit.btn.addEventListener('click', () => switchTab('edit'));
            tabs.extract.btn.addEventListener('click', () => switchTab('extract'));
            tabs.merge.btn.addEventListener('click', () => switchTab('merge'));

            // --- NUCLEAR OPTION: Metadata Sanitization ---
            function cleanupPdf(pdfDoc) {
                try {
                    const catalog = pdfDoc.getCatalog();

                    // 1. Nuke document-level metadata roots
                    const keysToDelete = [
                        'StructTreeRoot',
                        'Outlines',
                        'MarkInfo',
                        'OCProperties',
                        'Lang',
                        'ViewerPreferences',
                        'PageLabels'
                    ];

                    keysToDelete.forEach(key => {
                        const name = PDFLib.PDFName.of(key);
                        if (catalog.has(name)) catalog.delete(name);
                    });

                    // 2. Nuke Page-Level Metadata (The silent killer for e.ascend)
                    // We must iterate pages and strip accessibility tags from each
                    const pages = pdfDoc.getPages();
                    const structParentsKey = PDFLib.PDFName.of('StructParents');
                    const tabsKey = PDFLib.PDFName.of('Tabs'); // sometimes linked to structure

                    for (const page of pages) {
                        if (page.node.has(structParentsKey)) page.node.delete(structParentsKey);
                        if (page.node.has(tabsKey)) page.node.delete(tabsKey);
                    }

                } catch (e) {
                    console.warn("Could not cleanup PDF structure", e);
                }
            }

            // --- Shared Helper: Render Thumbnail (Optimized for Large PDFs) ---
            async function renderPageThumbnail(pdfJsDoc, pageNum, container, clickHandler, isSelected = false) {
                const thumbnailDiv = document.createElement('div');
                thumbnailDiv.className = `page-thumbnail bg-white border border-gray-200 rounded-lg p-2 flex flex-col items-center cursor-pointer ${isSelected ? 'selected' : ''}`;
                thumbnailDiv.dataset.pageIndex = pageNum - 1;

                const badge = document.createElement('div');
                badge.className = 'page-badge';
                badge.innerHTML = '<i class="fas fa-check"></i>';
                thumbnailDiv.appendChild(badge);

                const canvas = document.createElement('canvas');
                canvas.className = 'w-full h-32 object-contain mb-2';

                try {
                    const page = await pdfJsDoc.getPage(pageNum);
                    // Use smaller scale for memory efficiency
                    const viewport = page.getViewport({ scale: 0.15 });
                    canvas.width = viewport.width;
                    canvas.height = viewport.height;

                    const ctx = canvas.getContext('2d');
                    await page.render({ canvasContext: ctx, viewport: viewport }).promise;

                    // Clean up page resources immediately after rendering
                    page.cleanup();
                } catch (err) {
                    // If rendering fails, show placeholder
                    canvas.width = 100;
                    canvas.height = 130;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#f0f0f0';
                    ctx.fillRect(0, 0, 100, 130);
                    ctx.fillStyle = '#999';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Preview', 50, 65);
                    ctx.fillText('unavailable', 50, 80);
                }

                const pageLabel = document.createElement('span');
                pageLabel.className = 'text-sm text-gray-700 font-medium';
                pageLabel.textContent = `Page ${pageNum}`;

                thumbnailDiv.appendChild(canvas);
                thumbnailDiv.appendChild(pageLabel);

                if (clickHandler) {
                    thumbnailDiv.addEventListener('click', () => clickHandler(pageNum, thumbnailDiv));
                }

                container.appendChild(thumbnailDiv);
            }

            // --- Helper: Batch render thumbnails with delays to prevent freezing ---
            async function renderThumbnailsInBatches(pdfJsDoc, container, clickHandler, startPage = 1, endPage = null, batchSize = 10) {
                const totalPages = endPage || pdfJsDoc.numPages;
                const pagesToRender = Math.min(totalPages, 200); // Cap at 200 thumbnails

                for (let i = startPage; i <= pagesToRender; i += batchSize) {
                    const batchEnd = Math.min(i + batchSize - 1, pagesToRender);
                    const promises = [];

                    for (let j = i; j <= batchEnd; j++) {
                        promises.push(renderPageThumbnail(pdfJsDoc, j, container, clickHandler));
                    }

                    await Promise.all(promises);

                    // Yield to browser to prevent freezing
                    await new Promise(resolve => setTimeout(resolve, 10));
                }

                // Show message if pages were capped
                if (totalPages > 200) {
                    const moreDiv = document.createElement('div');
                    moreDiv.className = 'col-span-full text-center p-4 text-gray-500 italic bg-yellow-50 rounded-lg';
                    moreDiv.innerHTML = `<i class="fas fa-info-circle mr-2"></i>Showing first 200 of ${totalPages} pages. Use the page range input for other pages.`;
                    container.appendChild(moreDiv);
                }
            }

            // --- Edit PDF Functionality ---
            const pdfInput = document.getElementById('pdfInput');
            const editDropzone = document.getElementById('editDropzone');
            const pdfInfo = document.getElementById('pdfInfo');
            const pageThumbnails = document.getElementById('pageThumbnails');
            const processEditBtn = document.getElementById('processEditBtn');
            const selectAllBtn = document.getElementById('selectAllBtn');
            const deselectAllBtn = document.getElementById('deselectAllBtn');

            let pdfDoc = null;
            let selectedPagesToRemove = [];

            editDropzone.addEventListener('click', () => pdfInput.click());
            pdfInput.addEventListener('change', async (e) => {
                if (e.target.files.length === 0) return;
                await loadEditPdf(e.target.files[0]);
                e.target.value = '';
            });

            setupDropzone(editDropzone, async (file) => await loadEditPdf(file));

            async function loadEditPdf(file) {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer, {
                        ignoreEncryption: true,
                        updateMetadata: false
                    });
                    cleanupPdf(pdfDoc);

                    pageThumbnails.innerHTML = '';
                    selectedPagesToRemove = [];
                    processEditBtn.disabled = true;

                    const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
                    const pdfJsDoc = await loadingTask.promise;

                    const totalPages = pdfJsDoc.numPages;
                    if (totalPages > 200) {
                        // Show info message about large file
                        const infoDiv = document.createElement('div');
                        infoDiv.className = 'col-span-full text-center p-4 text-orange-600 bg-orange-50 rounded-lg mb-4';
                        infoDiv.innerHTML = `<i class="fas fa-exclamation-triangle mr-2"></i>Large file (${totalPages} pages). Showing first 200 thumbnails. All pages can still be processed.`;
                        pageThumbnails.appendChild(infoDiv);
                    }

                    // Use batched rendering for better performance
                    await renderThumbnailsInBatches(pdfJsDoc, pageThumbnails, toggleEditSelection);

                    pdfInfo.classList.remove('hidden');
                } catch (error) {
                    console.error('Error loading PDF:', error);
                    alert('Error loading PDF: ' + error.message);
                }
            }

            function toggleEditSelection(pageNum, element) {
                const pageIndex = pageNum - 1;
                const index = selectedPagesToRemove.indexOf(pageIndex);
                if (index === -1) {
                    selectedPagesToRemove.push(pageIndex);
                    element.classList.add('selected');
                } else {
                    selectedPagesToRemove.splice(index, 1);
                    element.classList.remove('selected');
                }
                processEditBtn.disabled = selectedPagesToRemove.length === 0;
            }

            selectAllBtn.addEventListener('click', () => {
                selectedPagesToRemove = [];
                const thumbnails = pageThumbnails.querySelectorAll('.page-thumbnail');
                thumbnails.forEach((thumb) => {
                    const pageIndex = parseInt(thumb.dataset.pageIndex);
                    selectedPagesToRemove.push(pageIndex);
                    thumb.classList.add('selected');
                });
                processEditBtn.disabled = selectedPagesToRemove.length === 0;
            });

            deselectAllBtn.addEventListener('click', () => {
                selectedPagesToRemove = [];
                const thumbnails = pageThumbnails.querySelectorAll('.page-thumbnail');
                thumbnails.forEach(thumb => thumb.classList.remove('selected'));
                processEditBtn.disabled = true;
            });

            processEditBtn.addEventListener('click', async () => {
                if (!pdfDoc || selectedPagesToRemove.length === 0) return;

                const originalBtnText = processEditBtn.innerHTML;
                processEditBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Processing...';
                processEditBtn.disabled = true;

                try {
                    selectedPagesToRemove.sort((a, b) => b - a);
                    for (const pageIndex of selectedPagesToRemove) {
                        pdfDoc.removePage(pageIndex);
                    }

                    const pdfBytes = await pdfDoc.save();
                    download(pdfBytes, "edited_document.pdf", "application/pdf");
                } catch (error) {
                    console.error('Error processing PDF:', error);
                    alert('Error processing PDF.');
                } finally {
                    processEditBtn.innerHTML = originalBtnText;
                    processEditBtn.disabled = false;
                }
            });

            // --- Extract PDF Functionality ---
            const extractPdfInput = document.getElementById('extractPdfInput');
            const extractDropzone = document.getElementById('extractDropzone');
            const extractWorkArea = document.getElementById('extractWorkArea');
            const extractSourceThumbnails = document.getElementById('extractSourceThumbnails');
            const extractResultThumbnails = document.getElementById('extractResultThumbnails');
            const extractPreviewArea = document.getElementById('extractPreviewArea');
            const btnPreviewExtract = document.getElementById('btnPreviewExtract');
            const btnDownloadExtract = document.getElementById('btnDownloadExtract');
            const pageRangeInput = document.getElementById('pageRange');
            const outputFilenameInput = document.getElementById('outputFilename');
            const largeFileMsg = document.getElementById('largeFileMsg');
            const loadThumbnailsOverlay = document.getElementById('loadThumbnailsOverlay');
            const btnLoadThumbnails = document.getElementById('btnLoadThumbnails');

            let extractPdfDocFile = null;
            let extractSourcePdfJs = null;
            let selectedExtractPages = new Set();
            let finalExtractedBytes = null;

            extractDropzone.addEventListener('click', () => extractPdfInput.click());
            extractPdfInput.addEventListener('change', async (e) => {
                if (e.target.files.length === 0) return;
                await loadExtractPdf(e.target.files[0]);
                e.target.value = '';
            });
            setupDropzone(extractDropzone, async (file) => await loadExtractPdf(file));

            async function loadExtractPdf(file) {
                try {
                    extractPdfDocFile = file;
                    const arrayBuffer = await file.arrayBuffer();
                    const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
                    extractSourcePdfJs = await loadingTask.promise;

                    extractSourceThumbnails.innerHTML = '';
                    extractResultThumbnails.innerHTML = '';
                    selectedExtractPages.clear();
                    pageRangeInput.value = '';
                    extractPreviewArea.classList.add('hidden');
                    btnPreviewExtract.disabled = false;
                    largeFileMsg.classList.add('hidden');
                    loadThumbnailsOverlay.classList.add('hidden');

                    const totalPages = extractSourcePdfJs.numPages;
                    const THUMBNAIL_LIMIT = 100;

                    if (totalPages > THUMBNAIL_LIMIT) {
                        largeFileMsg.classList.remove('hidden');
                        loadThumbnailsOverlay.classList.remove('hidden');
                        btnLoadThumbnails.onclick = async () => {
                            loadThumbnailsOverlay.classList.add('hidden');
                            await renderAllExtractThumbnails(extractSourcePdfJs);
                        };
                    } else {
                        await renderAllExtractThumbnails(extractSourcePdfJs);
                    }

                    extractWorkArea.classList.remove('hidden');
                } catch (error) {
                    console.error('Error loading PDF for extraction:', error);
                    alert('Error loading PDF.');
                }
            }

            async function renderAllExtractThumbnails(pdfJsDoc) {
                // Use batched rendering for better performance on large PDFs
                await renderThumbnailsInBatches(pdfJsDoc, extractSourceThumbnails, toggleExtractSelection);
            }

            function toggleExtractSelection(pageNum, element) {
                const pageIndex = pageNum - 1;
                if (selectedExtractPages.has(pageIndex)) {
                    selectedExtractPages.delete(pageIndex);
                    element.classList.remove('selected');
                } else {
                    selectedExtractPages.add(pageIndex);
                    element.classList.add('selected');
                }
                updateRangeInputFromSelection();
            }

            function updateRangeInputFromSelection() {
                const sorted = Array.from(selectedExtractPages).sort((a, b) => a - b);
                const oneBased = sorted.map(i => i + 1);
                pageRangeInput.value = oneBased.join(', ');
            }

            pageRangeInput.addEventListener('input', () => {
                const val = pageRangeInput.value;
                const pages = new Set();
                const maxPages = extractSourcePdfJs ? extractSourcePdfJs.numPages : 0;

                if (!maxPages) return;

                const parts = val.split(',');
                parts.forEach(part => {
                    const p = part.trim();
                    if (p.includes('-')) {
                        const [start, end] = p.split('-').map(num => parseInt(num));
                        if (!isNaN(start) && !isNaN(end)) {
                            const s = Math.max(1, Math.min(start, end));
                            const e = Math.min(maxPages, Math.max(start, end));
                            for (let i = s; i <= e; i++) pages.add(i - 1);
                        }
                    } else {
                        const num = parseInt(p);
                        if (!isNaN(num) && num >= 1 && num <= maxPages) {
                            pages.add(num - 1);
                        }
                    }
                });

                selectedExtractPages = pages;
                const thumbs = extractSourceThumbnails.querySelectorAll('.page-thumbnail');
                if (thumbs.length > 0) {
                    thumbs.forEach(thumb => {
                        const idx = parseInt(thumb.dataset.pageIndex);
                        if (selectedExtractPages.has(idx)) {
                            thumb.classList.add('selected');
                        } else {
                            thumb.classList.remove('selected');
                        }
                    });
                }

                extractPreviewArea.classList.add('hidden');
            });

            // --- CORE LOGIC: Robust Extraction Engine (Handles Corrupted PDFs) ---
            async function performExtraction(indicesToKeep, progressCallback) {
                const arrayBuffer = await extractPdfDocFile.arrayBuffer();
                const sortedIndices = Array.from(indicesToKeep).sort((a, b) => a - b);
                const totalToCopy = sortedIndices.length;

                // ATTEMPT 1: Chunked Copy (fastest, works for most PDFs)
                try {
                    console.log(`ATTEMPT 1: Chunked Copy of ${totalToCopy} pages...`);
                    let pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer, {
                        ignoreEncryption: true,
                        updateMetadata: false
                    });
                    cleanupPdf(pdfDoc);

                    const newPdf = await PDFLib.PDFDocument.create();
                    const CHUNK_SIZE = 50;

                    for (let i = 0; i < sortedIndices.length; i += CHUNK_SIZE) {
                        const chunk = sortedIndices.slice(i, i + CHUNK_SIZE);
                        const copiedPages = await newPdf.copyPages(pdfDoc, chunk);
                        copiedPages.forEach(page => newPdf.addPage(page));

                        if (progressCallback) {
                            progressCallback(Math.min((i + CHUNK_SIZE) / totalToCopy * 100, 100));
                        }
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }

                    return await newPdf.save();

                } catch (error1) {
                    console.warn("ATTEMPT 1 failed:", error1.message);

                    // ATTEMPT 2: Single-page copy loop (slower but more resilient)
                    try {
                        console.log(`ATTEMPT 2: Single-page Copy of ${totalToCopy} pages...`);
                        let pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer, {
                            ignoreEncryption: true,
                            updateMetadata: false
                        });
                        cleanupPdf(pdfDoc);

                        const newPdf = await PDFLib.PDFDocument.create();

                        for (let i = 0; i < sortedIndices.length; i++) {
                            const pageIdx = sortedIndices[i];
                            try {
                                const [copiedPage] = await newPdf.copyPages(pdfDoc, [pageIdx]);
                                newPdf.addPage(copiedPage);
                            } catch (pageError) {
                                console.warn(`Skipped page ${pageIdx + 1} due to error:`, pageError.message);
                            }

                            if (progressCallback && i % 10 === 0) {
                                progressCallback(Math.min((i / totalToCopy) * 100, 100));
                                await new Promise(resolve => setTimeout(resolve, 0));
                            }
                        }

                        if (newPdf.getPageCount() === 0) {
                            throw new Error("No pages could be copied");
                        }

                        return await newPdf.save();

                    } catch (error2) {
                        console.warn("ATTEMPT 2 failed:", error2.message);

                        // ATTEMPT 3: Embed pages as XObjects (most resilient, handles corrupt structure)
                        try {
                            console.log(`ATTEMPT 3: Page Embedding of ${totalToCopy} pages...`);
                            let pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer, {
                                ignoreEncryption: true,
                                updateMetadata: false
                            });

                            const newPdf = await PDFLib.PDFDocument.create();

                            for (let i = 0; i < sortedIndices.length; i++) {
                                const pageIdx = sortedIndices[i];
                                try {
                                    const srcPage = pdfDoc.getPage(pageIdx);
                                    const { width, height } = srcPage.getSize();

                                    // Embed the page as a form XObject and draw it
                                    const [embeddedPage] = await newPdf.embedPdf(pdfDoc, [pageIdx]);
                                    const newPage = newPdf.addPage([width, height]);
                                    newPage.drawPage(embeddedPage, {
                                        x: 0,
                                        y: 0,
                                        width: width,
                                        height: height
                                    });
                                } catch (pageError) {
                                    console.warn(`Skipped page ${pageIdx + 1} during embedding:`, pageError.message);
                                }

                                if (progressCallback && i % 5 === 0) {
                                    progressCallback(Math.min((i / totalToCopy) * 100, 100));
                                    await new Promise(resolve => setTimeout(resolve, 0));
                                }
                            }

                            if (newPdf.getPageCount() === 0) {
                                throw new Error("No pages could be embedded");
                            }

                            return await newPdf.save();

                        } catch (error3) {
                            console.warn("ATTEMPT 3 failed:", error3.message);

                            // ATTEMPT 4: Canvas Rasterization (ultimate fallback - uses pdf.js rendering)
                            // This completely bypasses pdf-lib's structural parsing
                            try {
                                console.log(`ATTEMPT 4: Canvas Rasterization of ${totalToCopy} pages...`);

                                // Use pdf.js which can render the document even if structure is corrupt
                                const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
                                const pdfJsDoc = await loadingTask.promise;

                                const newPdf = await PDFLib.PDFDocument.create();
                                const RENDER_SCALE = 2; // Higher = better quality but larger file

                                for (let i = 0; i < sortedIndices.length; i++) {
                                    const pageIdx = sortedIndices[i];
                                    const pageNum = pageIdx + 1;

                                    try {
                                        // Render page with pdf.js
                                        const page = await pdfJsDoc.getPage(pageNum);
                                        const viewport = page.getViewport({ scale: RENDER_SCALE });

                                        // Create canvas and render
                                        const canvas = document.createElement('canvas');
                                        canvas.width = viewport.width;
                                        canvas.height = viewport.height;
                                        const ctx = canvas.getContext('2d');

                                        await page.render({
                                            canvasContext: ctx,
                                            viewport: viewport
                                        }).promise;

                                        // Convert canvas to PNG blob
                                        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                                        const imgArrayBuffer = await blob.arrayBuffer();
                                        const imgBytes = new Uint8Array(imgArrayBuffer);

                                        // Embed image in new PDF
                                        const pngImage = await newPdf.embedPng(imgBytes);

                                        // Calculate page size (in points, at 72 DPI)
                                        const origWidth = viewport.width / RENDER_SCALE;
                                        const origHeight = viewport.height / RENDER_SCALE;

                                        const newPage = newPdf.addPage([origWidth, origHeight]);
                                        newPage.drawImage(pngImage, {
                                            x: 0,
                                            y: 0,
                                            width: origWidth,
                                            height: origHeight
                                        });

                                        // Cleanup
                                        page.cleanup();

                                    } catch (pageError) {
                                        console.warn(`Skipped page ${pageNum} during rasterization:`, pageError.message);
                                    }

                                    if (progressCallback) {
                                        progressCallback(Math.min(((i + 1) / totalToCopy) * 100, 100));
                                    }

                                    // Yield to browser and allow GC every page
                                    await new Promise(resolve => setTimeout(resolve, 10));
                                }

                                if (newPdf.getPageCount() === 0) {
                                    throw new Error("No pages could be rasterized");
                                }

                                console.log(`Successfully rasterized ${newPdf.getPageCount()} pages`);
                                return await newPdf.save();

                            } catch (error4) {
                                console.error("All 4 extraction methods failed:", error4);
                                throw new Error(`Extraction failed after trying 4 methods. This PDF may be encrypted or use unsupported features. Last error: ${error4.message}`);
                            }
                        }
                    }
                }
            }

            btnPreviewExtract.addEventListener('click', async () => {
                if (selectedExtractPages.size === 0 && pageRangeInput.value.trim() !== "") {
                    const val = pageRangeInput.value;
                    const maxPages = extractSourcePdfJs.numPages;
                    const parts = val.split(',');
                    parts.forEach(part => {
                        const p = part.trim();
                        if (p.includes('-')) {
                            const [start, end] = p.split('-').map(num => parseInt(num));
                            if (!isNaN(start) && !isNaN(end)) {
                                const s = Math.max(1, Math.min(start, end));
                                const e = Math.min(maxPages, Math.max(start, end));
                                for (let i = s; i <= e; i++) selectedExtractPages.add(i - 1);
                            }
                        } else {
                            const num = parseInt(p);
                            if (!isNaN(num) && num >= 1 && num <= maxPages) {
                                selectedExtractPages.add(num - 1);
                            }
                        }
                    });
                }

                if (selectedExtractPages.size === 0) {
                    alert("Please select pages or type a page range.");
                    return;
                }

                const originalText = btnPreviewExtract.innerHTML;
                btnPreviewExtract.disabled = true;

                // Progress callback to update button text
                const updateProgress = (percent) => {
                    btnPreviewExtract.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>Processing... ${Math.round(percent)}%`;
                };
                btnPreviewExtract.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Processing... 0%';

                try {
                    // Start Hybrid Extraction with progress updates
                    finalExtractedBytes = await performExtraction(selectedExtractPages, updateProgress);

                    btnPreviewExtract.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Generating preview...';

                    // Render Preview using batched approach
                    const loadingTask = pdfjsLib.getDocument({ data: finalExtractedBytes });
                    const resultPdfJs = await loadingTask.promise;

                    extractResultThumbnails.innerHTML = '';

                    // Use batched rendering for preview with lower limit
                    const previewLimit = Math.min(resultPdfJs.numPages, 30);
                    for (let i = 1; i <= previewLimit; i++) {
                        await renderPageThumbnail(resultPdfJs, i, extractResultThumbnails, null, false);
                        // Yield every 5 pages to keep UI responsive
                        if (i % 5 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 10));
                        }
                    }

                    if (resultPdfJs.numPages > 30) {
                        const moreDiv = document.createElement('div');
                        moreDiv.className = 'col-span-full flex items-center justify-center p-4 text-gray-500 italic bg-green-50 rounded-lg';
                        moreDiv.innerHTML = `<i class="fas fa-check-circle text-green-500 mr-2"></i>PDF ready! ${resultPdfJs.numPages} total pages (showing preview of first 30)`;
                        extractResultThumbnails.appendChild(moreDiv);
                    }

                    extractPreviewArea.classList.remove('hidden');
                    extractPreviewArea.scrollIntoView({ behavior: 'smooth' });

                } catch (error) {
                    console.error('Final Extraction Failure:', error);
                    alert('Extraction failed. Error: ' + error.message + '\n\nTry a smaller page range or check if the PDF is corrupted.');
                } finally {
                    btnPreviewExtract.innerHTML = originalText;
                    btnPreviewExtract.disabled = false;
                }
            });

            btnDownloadExtract.addEventListener('click', () => {
                if (!finalExtractedBytes) return;

                let filename = outputFilenameInput.value.trim() || 'extracted_pages';
                if (!filename.toLowerCase().endsWith('.pdf')) filename += '.pdf';

                download(finalExtractedBytes, filename, "application/pdf");
            });

            // --- Merge PDF Functionality ---
            const mergePdfInput = document.getElementById('mergePdfInput');
            const mergeDropzone = document.getElementById('mergeDropzone');
            const mergeFilesList = document.getElementById('mergeFilesList');
            const mergeList = document.getElementById('mergeList');
            const processMergeBtn = document.getElementById('processMergeBtn');
            const clearMergeBtn = document.getElementById('clearMergeBtn');
            let mergeFiles = [];
            let dragSrcIndex = null;

            mergeDropzone.addEventListener('click', () => mergePdfInput.click());
            mergePdfInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) handleMergeFiles(e.target.files);
                e.target.value = '';
            });

            setupDropzone(mergeDropzone, (file) => {
                handleMergeFiles([file]);
            });

            function handleMergeFiles(files) {
                Array.from(files).forEach(file => {
                    if (file.type === 'application/pdf' && !mergeFiles.some(f => f.name === file.name && f.size === file.size)) {
                        mergeFiles.push(file);
                    }
                });
                updateMergeList();
                mergeFilesList.classList.remove('hidden');
                processMergeBtn.disabled = mergeFiles.length === 0;
            }

            function updateMergeList() {
                mergeList.innerHTML = '';
                mergeFiles.forEach((file, index) => {
                    const li = document.createElement('li');
                    li.className = 'bg-gray-50 rounded-lg p-3 flex items-center justify-between border border-gray-200 cursor-move';
                    li.draggable = true;
                    li.dataset.index = index;

                    const fileInfo = document.createElement('div');
                    fileInfo.className = 'flex items-center space-x-3';
                    fileInfo.innerHTML = `
                        <i class="fas fa-file-pdf text-red-500"></i>
                        <span class="text-gray-700 truncate max-w-xs">${file.name}</span>
                        <span class="text-gray-500 text-sm">${formatFileSize(file.size)}</span>
                    `;

                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'text-red-500 hover:text-red-700';
                    removeBtn.innerHTML = '<i class="fas fa-times"></i>';
                    removeBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        mergeFiles.splice(index, 1);
                        updateMergeList();
                        processMergeBtn.disabled = mergeFiles.length === 0;
                        if (mergeFiles.length === 0) mergeFilesList.classList.add('hidden');
                    });

                    li.appendChild(fileInfo);
                    li.appendChild(removeBtn);

                    li.addEventListener('dragstart', function (e) {
                        dragSrcIndex = this.dataset.index;
                        e.dataTransfer.effectAllowed = 'move';
                        e.dataTransfer.setData('text/html', this.innerHTML);
                        this.classList.add('bg-blue-50', 'border-blue-200');
                    });

                    li.addEventListener('dragover', function (e) {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        return false;
                    });

                    li.addEventListener('drop', function (e) {
                        e.stopPropagation();
                        if (dragSrcIndex !== this.dataset.index) {
                            const dragSrcLi = mergeFiles[dragSrcIndex];
                            mergeFiles.splice(dragSrcIndex, 1);
                            mergeFiles.splice(this.dataset.index, 0, dragSrcLi);
                            updateMergeList();
                        }
                        return false;
                    });
                    li.addEventListener('dragend', function () {
                        this.classList.remove('bg-blue-50', 'border-blue-200');
                    });

                    mergeList.appendChild(li);
                });
            }

            processMergeBtn.addEventListener('click', async () => {
                if (mergeFiles.length === 0) {
                    alert('Please add PDF files to merge first');
                    return;
                }
                const originalBtnText = processMergeBtn.innerHTML;
                processMergeBtn.disabled = true;

                const updateProgress = (fileIndex, totalFiles) => {
                    const percent = Math.round((fileIndex / totalFiles) * 100);
                    processMergeBtn.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>Merging... ${percent}% (File ${fileIndex}/${totalFiles})`;
                };
                processMergeBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Merging... 0%';

                try {
                    const newPdf = await PDFLib.PDFDocument.create();
                    const CHUNK_SIZE = 50; // Copy pages in chunks

                    for (let fileIdx = 0; fileIdx < mergeFiles.length; fileIdx++) {
                        const file = mergeFiles[fileIdx];
                        updateProgress(fileIdx + 1, mergeFiles.length);

                        const arrayBuffer = await file.arrayBuffer();
                        const pdf = await PDFLib.PDFDocument.load(arrayBuffer, {
                            ignoreEncryption: true,
                            updateMetadata: false
                        });
                        cleanupPdf(pdf);

                        const pageCount = pdf.getPageCount();
                        if (pageCount === 0) continue;

                        // Copy pages in chunks to prevent memory issues
                        const pageIndices = pdf.getPageIndices();
                        for (let i = 0; i < pageIndices.length; i += CHUNK_SIZE) {
                            const chunk = pageIndices.slice(i, i + CHUNK_SIZE);
                            const pages = await newPdf.copyPages(pdf, chunk);
                            pages.forEach(page => newPdf.addPage(page));

                            // Yield to browser
                            await new Promise(resolve => setTimeout(resolve, 0));
                        }
                    }

                    if (newPdf.getPageCount() === 0) {
                        alert('No valid pages found in the selected PDFs');
                        return;
                    }

                    processMergeBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Saving...';
                    const pdfBytes = await newPdf.save();
                    download(pdfBytes, "merged_document.pdf", "application/pdf");
                } catch (error) {
                    console.error('Error merging PDFs:', error);
                    alert('Error merging PDFs: ' + error.message);
                } finally {
                    processMergeBtn.innerHTML = originalBtnText;
                    processMergeBtn.disabled = false;
                }
            });

            clearMergeBtn.addEventListener('click', () => {
                mergeFiles = [];
                updateMergeList();
                mergeFilesList.classList.add('hidden');
                processMergeBtn.disabled = true;
            });

            // Helper functions
            function formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            function setupDropzone(element, callback) {
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    element.addEventListener(eventName, (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    }, false);
                });

                ['dragenter', 'dragover'].forEach(eventName => element.classList.add('active'));
                ['dragleave', 'drop'].forEach(eventName => element.classList.remove('active'));

                element.addEventListener('drop', (e) => {
                    const dt = e.dataTransfer;
                    const files = Array.from(dt.files).filter(file => file.type === 'application/pdf');
                    if (files.length > 0) callback(files[0]);
                    else alert('Please upload a PDF file');
                });
            }
        });
    </script>

</body>

</html>